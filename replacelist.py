from pytexutils import *

import re, os


def ReadFRPatternsFile(frfilename):#, keepblanks=False):
    """Read in a list of find and replace patterns (frpatterns) from a
    file.  The frpatterns often arise because of the output of Maxima.
    This allows specific strings in the Tex output of Maxima to be
    replaced with nicely formatted LaTeX commands.

    The file whose name is frfilename should be '&' delimited with
    one pattern per line:
        find1 & replace1
        find2 & replace2
        ...

    Keep in mind that the find and replace is (usually) done using
    regular expressions with word boundaries appended and prepended.
    The main thing this means is that escape symbols need to be
    doubled.
    """
    if not os.path.exists(frfilename):
        return []
    rawlist = readfile(frfilename)
    frlist = []
    #blanklist = []
    filtlist=[line for line in rawlist if line]
    for line in filtlist:
        curfind, currep = line.split('&',1)
        hasb = 0
        if currep.find('&') > -1:
            currep, useboundaries = currep.split('&')
            useboundaries = useboundaries.strip()
            useboundaries = int(useboundaries)
            hasb = 1
        curfind = curfind.strip()
        currep = currep.strip()
        if currep:# or keepblanks:#allow for the possiblity of a blank replacement that was autogenerated.
            if hasb:
                curtup = (curfind, currep, useboundaries)
            else:
                curtup = (curfind, currep)
            frlist.append(curtup)
#            print('curtup='+str(curtup))
       # else:
       #     blanklist.append(curfind)
       #     print('skipping:'+curfind)
    return frlist#, blanklist


def AppendFRPatterns(newlist, frpath='frpatterns.txt', append=True,removeDoubles=True):
    newlist.sort()
    outlist = newlist
    if (not os.path.exists(frpath)) or (not append):
        f = open(frpath, 'w')
    else:
        if removeDoubles:
            curList = ReadFindsFromPatternsFile(frpath)
            curList.sort()
            outlist = [i for i in newlist if i.strip() not in curList]
            outlist.sort()
        f=open(frpath,'a')
    replist = [item.replace('{\\it','{\\\\it') for item in outlist]
    replist = [item.strip() for item in replist]
    outlist = [item +' &\n' for item in replist]
    f.writelines(outlist)
    f.close()
    return outlist


def ReadFindsFromPatternsFile(frfilename, keepblanks=False):
    """Read in only the search or find strings from an frpatterns
    file, so that we will know what new ones to append."""
    if not os.path.exists(frfilename):
        return []
    rawlist = readfile(frfilename)
    findlist = []
    filtlist=[line for line in rawlist if line]
    for line in filtlist:
        curfind, currep = line.split('&',1)
        curfind = curfind.strip()
        if curfind:
            findlist.append(curfind)
    return findlist


class Replacer:
    """This class has one pattern or search string and one replacement
    string and searches a string or list of strings making
    replacements, using regexps or standard string search and replace
    operations."""
    def __init__(self, pat, replacement, reopt=1):
        """Create an instance of the Replacer class. pat is the string
        or regexp pattern to search for, the replacement is the
        replacement string, and the optional input reopt is an
        integer from 0 to 2.  0 means regexp without adding work
        boundaries to the pattern, 1 means regexp with added word
        boundaries (this is the default), and 2 means standard string
        search and replace without regexp."""
        self.pat = pat
        self.replacement = replacement
        self.reopt = int(reopt)
        self.compilere()


    def compilere(self):
        if self.reopt == 0:
            self.p = re.compile(self.pat)
        elif self.reopt ==1:
            self.p = re.compile('\\b'+self.pat+'\\b')
        else:
            self.p = None


    def ReplaceString(self, strin):
        if self.p:
            strout = self.p.sub(self.replacement, strin)
        else:
            strout = strin.replace(self.pat, self.replacement)
        return strout


    def Match(self, strin):
        if self.p:
            q = self.p.match(strin)
            if q:
                return True
        else:
            ind = self.p.find(strin)
            if ind > -1:
                return True
        return False



class ReplaceList:
    def __init__(self, listin=[], frpath='frpatterns.txt', walkpath=None):
        if walkpath is None:
            walkpath = os.getcwd()
        if not os.path.exists(frpath):
            mypath = FindWalkingUp(frpath, walkpath)
            if mypath:
                frpath = mypath
            else:
                frpath = 'frpatterns.txt'
        self.frlist = copy.copy(listin)
        self.frpath = frpath
        self.replacers = []


    def ReadFRFile(self, pathin=None, append=True):
        """If path in is None, use self.frpath.  If not append,
        replace self.frlist with the results of reading the file,
        otherwise extend the list (no checking is done for duplicate
        entries)."""
        if pathin is None:
            pathin = self.frpath
        if append:
            self.frlist.extend(ReadFRPatternsFile(pathin))
        else:
            self.frlist = ReadFRPatternsFile(pathin)
        return self.frlist


    def BuildReplacerList(self):
        self.replacers = [Replacer(*line) for line in self.frlist]
        

    def _GetReady(self):
        """Used to make sure that self is ready for most actions by
        creating the self.replacers list if it is empty."""
        if not self.replacers:
            self.BuildReplacerList()


    def ReplaceOne(self, line):#, onlyone=False):
        self._GetReady()
        if not self.replacers:
            return line
        curout = line
        for replacer in self.replacers:
            curout = replacer.ReplaceString(curout)
            #if onlyone and (curout!=line):
            #    break
        return curout


    def Replace(self, listin):
        self._GetReady()
        strin = False
        #print('listin[0]='+listin[0])
        if type(listin)==str:
            listin = [listin]
            strin = True
        outlist = []
        for line in listin:
            curout = self.ReplaceOne(line)
            outlist.append(curout)
        #print('outlist[0]='+outlist[0])
        #print('===================')
        if strin:
            return outlist[0]
        else:
            return outlist
        
            
    def Match(self, strin):
        self._GetReady()
        for replacer in self.replacers:
            if replacer.Match(strin):
                return True
        return False
    
            
    def FindNew(self, newpats):
        filtpats = [item for item in newpats if not self.Match(item)]
        new2 = [item.replace('{\\it','{\\\\it') for item in filtpats]
        existsingpats = ReadFindsFromPatternsFile(self.frpath)
        filt2 = [item for item in new2 if item not in existsingpats]
        return filt2


    def AppendFRFile(self, allpats):
        self._GetReady()
        newpats = self.FindNew(allpats)
        outlist = AppendFRPatterns(newpats, frpath=self.frpath, append=True)
        return outlist
        

        
class EquationCleaner:
    """This class exists to take a LaTeX file generated by the
    Python->Maxima->Latex engine and pretty-up the output primarily by
    replacing variable names."""
    def __init__(self,inputname,frnamein='frpatterns.txt'):
        self.inputname=inputname
        self.frname=frnamein
        self.list=[]
        self.readfile(inputname)
        mypath, fno = os.path.split(inputname)
        print('mypath='+mypath)
        self.path = mypath
        temppath = os.path.join(self.path, self.frname)
        print('temppath='+temppath)
        if os.path.exists(temppath):
            self.frname = temppath
            print('self.frname='+self.frname)


    def AppendFRPatterns(self,frpath=None):
        if frpath is None:
            frpath=os.path.join(self.path,self.frname)
        frlist = self.ReadFRPatterns(frpath,keepblanks=True)
        mylist = self.MakeReplacementList()
        replist = [item.strip() for item in mylist]
        if frlist:
            searchlist = zip(*frlist)[0]
            filtlist = [item for item in replist if item not in searchlist]
            outlist = [item +' &\n' for item in filtlist]
        else:
            outlist = [item +' &\n' for item in replist]
            frname = os.path.join(self.path,'frpatterns.txt')#save frpatterns to directory of tex file
        print('EquationCleaner frpath='+frpath)
        cwd = os.getcwd()
        print('current directory='+cwd)
        f=open(frpath,'a')
        f.writelines(outlist)
        f.close()
        return outlist


    def MakeReplacementList(self):
        lhslist = self.FullLHSList()
        itlist = []
        p = re.compile(r'{\\it .*?}')
        for line in self.list:
            q = p.findall(line)
            for item in q:
                if item not in itlist:
                    itlist.append(item)
        filtlhs = [item for item in lhslist if item.find('\\')==-1]
        biglist = filtlhs + itlist
        return biglist
